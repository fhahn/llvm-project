; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -passes='default<O3>' -S %s | FileCheck %s

target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
target triple = "arm64-apple-macosx11.0.0"

define void @test(i32 %0) {
; CHECK-LABEL: define void @test(
; CHECK-SAME: i32 [[TMP0:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP141:%.*]] = icmp sgt i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[CMP141]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext nneg i32 [[TMP0]] to i64
; CHECK-NEXT:    [[XTRAITER:%.*]] = and i64 [[WIDE_TRIP_COUNT]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[TMP0]], 1
; CHECK-NEXT:    br i1 [[TMP1]], label [[FOR_COND_CLEANUP_LOOPEXIT_UNR_LCSSA:%.*]], label [[FOR_BODY_PREHEADER_NEW:%.*]]
; CHECK:       for.body.preheader.new:
; CHECK-NEXT:    [[UNROLL_ITER:%.*]] = and i64 [[WIDE_TRIP_COUNT]], 2147483646
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER_NEW]] ], [ [[INDVARS_IV_NEXT_1:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CALL15:%.*]] = load volatile <8 x half>, ptr null, align 4294967296
; CHECK-NEXT:    [[ARRAYIDX17:%.*]] = getelementptr <8 x half>, ptr null, i64 [[INDVARS_IV]]
; CHECK-NEXT:    store <8 x half> poison, ptr [[ARRAYIDX17]], align 32
; CHECK-NEXT:    [[INDVARS_IV_NEXT:%.*]] = or disjoint i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[CALL15_1:%.*]] = load volatile <8 x half>, ptr null, align 4294967296
; CHECK-NEXT:    [[ARRAYIDX17_1:%.*]] = getelementptr <8 x half>, ptr null, i64 [[INDVARS_IV_NEXT]]
; CHECK-NEXT:    store <8 x half> poison, ptr [[ARRAYIDX17_1]], align 16
; CHECK-NEXT:    [[INDVARS_IV_NEXT_1]] = add i64 [[INDVARS_IV]], 2
; CHECK-NEXT:    [[NITER_NCMP_1:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT_1]], [[UNROLL_ITER]]
; CHECK-NEXT:    br i1 [[NITER_NCMP_1]], label [[FOR_COND_CLEANUP_LOOPEXIT_UNR_LCSSA]], label [[FOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       for.cond.cleanup.loopexit.unr-lcssa:
; CHECK-NEXT:    [[INDVARS_IV_UNR:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT_1]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[LCMP_MOD_NOT:%.*]] = icmp eq i64 [[XTRAITER]], 0
; CHECK-NEXT:    br i1 [[LCMP_MOD_NOT]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY_EPIL:%.*]]
; CHECK:       for.body.epil:
; CHECK-NEXT:    [[CALL15_EPIL:%.*]] = load volatile <8 x half>, ptr null, align 4294967296
; CHECK-NEXT:    [[ARRAYIDX17_EPIL:%.*]] = getelementptr <8 x half>, ptr null, i64 [[INDVARS_IV_UNR]]
; CHECK-NEXT:    store <8 x half> poison, ptr [[ARRAYIDX17_EPIL]], align 16
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp14 = icmp slt i32 %i.0, %0
  br i1 %cmp14, label %for.body, label %for.cond.cleanup

for.body:                                         ; preds = %for.cond
  %call15 = load volatile <8 x half>, ptr null, align 16
  %idxprom16 = zext i32 %i.0 to i64
  %arrayidx17 = getelementptr <8 x half>, ptr null, i64 %idxprom16
  store <8 x half> zeroinitializer, ptr %arrayidx17, align 16
  %inc = add i32 %i.0, 1
  br label %for.cond, !llvm.loop !0

for.cond.cleanup:                                 ; preds = %for.cond
  ret void
}

!0 = distinct !{!0, !1, !2}
!1 = !{!"llvm.loop.mustprogress"}
!2 = !{!"llvm.loop.unroll.count", i32 2}
;.
; CHECK: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]], [[META2:![0-9]+]]}
; CHECK: [[META1]] = !{!"llvm.loop.mustprogress"}
; CHECK: [[META2]] = !{!"llvm.loop.unroll.disable"}
;.
