; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -loop-vectorize -force-vector-width=2 %s -S | FileCheck %s

target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"

define void @test1(double* %A, double* %B, i1 %c) {
; CHECK-LABEL: @test1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SELECT_A_OR_B:%.*]] = select i1 [[C:%.*]], double* [[A:%.*]], double* [[B:%.*]]
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = add i64 [[INDEX]], 0
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds double, double* [[SELECT_A_OR_B]], i64 [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds double, double* [[TMP1]], i32 0
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast double* [[TMP2]] to <2 x double>*
; CHECK-NEXT:    store <2 x double> zeroinitializer, <2 x double>* [[TMP3]], align 8
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 2
; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i64 [[INDEX_NEXT]], 20000
; CHECK-NEXT:    br i1 [[TMP4]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 20000, 20000
; CHECK-NEXT:    br i1 [[CMP_N]], label [[EXIT:%.*]], label [[SCALAR_PH]]
; CHECK:       scalar.ph:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ 20000, [[MIDDLE_BLOCK]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds double, double* [[SELECT_A_OR_B]], i64 [[IV]]
; CHECK-NEXT:    store double 0.000000e+00, double* [[GEP]], align 8
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
; CHECK-NEXT:    [[EC:%.*]] = icmp eq i64 [[IV_NEXT]], 20000
; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP2:![0-9]+]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %select.A.or.B = select i1 %c, double* %A, double* %B
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %gep = getelementptr inbounds double, double* %select.A.or.B, i64 %iv
  store double 0.0, double* %gep, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %ec = icmp eq i64 %iv.next, 20000
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

define void @test_crash() #0 {
entry:
  %.pre = load float*, float** undef, align 8
  %arrayidx.i170 = getelementptr inbounds float, float* %.pre, i64 0
  br label %for.body40

for.cond.loopexit.loopexit:                       ; preds = %for.body40
  ret void

for.body40:                                       ; preds = %for.body40, %entry
  %indvars.iv253 = phi i64 [ %indvars.iv.next254, %for.body40 ], [ 1, %entry ]
  %0 = load float, float* %arrayidx.i170, align 4
  %1 = trunc i64 %indvars.iv253 to i32
  %add.i185 = add i32 0, %1
  %idxprom.i186 = zext i32 %add.i185 to i64
  %arrayidx.i187 = getelementptr inbounds float, float* undef, i64 %idxprom.i186
  %2 = load float, float* %arrayidx.i187, align 4
  %add.i212 = add i32 undef, %1
  %idxprom.i213 = zext i32 %add.i212 to i64
  %arrayidx.i214 = getelementptr inbounds float, float* undef, i64 %idxprom.i213
  store float undef, float* %arrayidx.i214, align 4
  %indvars.iv.next254 = add nuw nsw i64 %indvars.iv253, 1
  %lftr.wideiv256 = trunc i64 %indvars.iv.next254 to i32
  %exitcond257.not = icmp eq i32 undef, %lftr.wideiv256
  br i1 %exitcond257.not, label %for.cond.loopexit.loopexit, label %for.body40
}
