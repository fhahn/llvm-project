; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=slp-vectorizer -mtriple=arm64-apple-ios -S %s | FileCheck %s

define void @v3_load_i32_mul_by_constant_store(ptr %src, ptr %dst) {
; CHECK-LABEL: @v3_load_i32_mul_by_constant_store(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_SRC_0:%.*]] = getelementptr inbounds i32, ptr [[SRC:%.*]], i32 0
; CHECK-NEXT:    [[TMP0:%.*]] = load <3 x i32>, ptr [[GEP_SRC_0]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <3 x i32> [[TMP0]], <3 x i32> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 4>
; CHECK-NEXT:    [[TMP2:%.*]] = mul nsw <4 x i32> [[TMP1]], <i32 10, i32 10, i32 10, i32 undef>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i32> [[TMP2]], <4 x i32> poison, <3 x i32> <i32 0, i32 1, i32 2>
; CHECK-NEXT:    store <3 x i32> [[TMP3]], ptr [[DST:%.*]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %gep.src.0 = getelementptr inbounds i32, ptr %src, i32 0
  %l.src.0 = load i32, ptr %gep.src.0, align 4
  %mul.0 = mul nsw i32 %l.src.0, 10

  %gep.src.1 = getelementptr inbounds i32, ptr %src, i32 1
  %l.src.1 = load i32, ptr %gep.src.1, align 4
  %mul.1 = mul nsw i32 %l.src.1, 10

  %gep.src.2 = getelementptr inbounds i32, ptr %src, i32 2
  %l.src.2 = load i32, ptr %gep.src.2, align 4
  %mul.2 = mul nsw i32 %l.src.2, 10

  store i32 %mul.0, ptr %dst

  %dst.1 = getelementptr i32, ptr %dst, i32 1
  store i32 %mul.1, ptr %dst.1

  %dst.2 = getelementptr i32, ptr %dst, i32 2
  store i32 %mul.2, ptr %dst.2

  ret void
}

define void @v3_load_i32_mul_store(ptr %src.1, ptr %src.2, ptr %dst) {
; CHECK-LABEL: @v3_load_i32_mul_store(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_SRC_1_0:%.*]] = getelementptr inbounds i32, ptr [[SRC_1:%.*]], i32 0
; CHECK-NEXT:    [[GEP_SRC_2_0:%.*]] = getelementptr inbounds i32, ptr [[SRC_2:%.*]], i32 0
; CHECK-NEXT:    [[TMP0:%.*]] = load <3 x i32>, ptr [[GEP_SRC_1_0]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <3 x i32> [[TMP0]], <3 x i32> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 4>
; CHECK-NEXT:    [[TMP2:%.*]] = load <3 x i32>, ptr [[GEP_SRC_2_0]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <3 x i32> [[TMP2]], <3 x i32> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 4>
; CHECK-NEXT:    [[TMP4:%.*]] = mul nsw <4 x i32> [[TMP1]], [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <4 x i32> [[TMP4]], <4 x i32> poison, <3 x i32> <i32 0, i32 1, i32 2>
; CHECK-NEXT:    store <3 x i32> [[TMP5]], ptr [[DST:%.*]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %gep.src.1.0 = getelementptr inbounds i32, ptr %src.1, i32 0
  %l.src.1.0 = load i32, ptr %gep.src.1.0, align 4
  %gep.src.2.0 = getelementptr inbounds i32, ptr %src.2, i32 0
  %l.src.2.0 = load i32, ptr %gep.src.2.0, align 4
  %mul.0 = mul nsw i32 %l.src.1.0, %l.src.2.0

  %gep.src.1.1 = getelementptr inbounds i32, ptr %src.1, i32 1
  %l.src.1.1 = load i32, ptr %gep.src.1.1, align 4
  %gep.src.2.1 = getelementptr inbounds i32, ptr %src.2, i32 1
  %l.src.2.1 = load i32, ptr %gep.src.2.1, align 4
  %mul.1 = mul nsw i32 %l.src.1.1, %l.src.2.1

  %gep.src.1.2 = getelementptr inbounds i32, ptr %src.1, i32 2
  %l.src.1.2 = load i32, ptr %gep.src.1.2, align 4
  %gep.src.2.2 = getelementptr inbounds i32, ptr %src.2, i32 2
  %l.src.2.2 = load i32, ptr %gep.src.2.2, align 4
  %mul.2 = mul nsw i32 %l.src.1.2, %l.src.2.2

  store i32 %mul.0, ptr %dst

  %dst.1 = getelementptr i32, ptr %dst, i32 1
  store i32 %mul.1, ptr %dst.1

  %dst.2 = getelementptr i32, ptr %dst, i32 2
  store i32 %mul.2, ptr %dst.2

  ret void
}

define void @v3_load_i32_mul_add_const_store(ptr %src.1, ptr %src.2, ptr %dst) {
; CHECK-LABEL: @v3_load_i32_mul_add_const_store(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_SRC_1_0:%.*]] = getelementptr inbounds i32, ptr [[SRC_1:%.*]], i32 0
; CHECK-NEXT:    [[GEP_SRC_2_0:%.*]] = getelementptr inbounds i32, ptr [[SRC_2:%.*]], i32 0
; CHECK-NEXT:    [[TMP0:%.*]] = load <3 x i32>, ptr [[GEP_SRC_1_0]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <3 x i32> [[TMP0]], <3 x i32> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 4>
; CHECK-NEXT:    [[TMP2:%.*]] = load <3 x i32>, ptr [[GEP_SRC_2_0]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <3 x i32> [[TMP2]], <3 x i32> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 4>
; CHECK-NEXT:    [[TMP4:%.*]] = mul nsw <4 x i32> [[TMP1]], [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = add <4 x i32> [[TMP4]], <i32 9, i32 9, i32 9, i32 undef>
; CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x i32> [[TMP5]], <4 x i32> poison, <3 x i32> <i32 0, i32 1, i32 2>
; CHECK-NEXT:    store <3 x i32> [[TMP6]], ptr [[DST:%.*]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %gep.src.1.0 = getelementptr inbounds i32, ptr %src.1, i32 0
  %l.src.1.0 = load i32, ptr %gep.src.1.0, align 4
  %gep.src.2.0 = getelementptr inbounds i32, ptr %src.2, i32 0
  %l.src.2.0 = load i32, ptr %gep.src.2.0, align 4
  %mul.0 = mul nsw i32 %l.src.1.0, %l.src.2.0
  %add.0 = add i32 %mul.0, 9

  %gep.src.1.1 = getelementptr inbounds i32, ptr %src.1, i32 1
  %l.src.1.1 = load i32, ptr %gep.src.1.1, align 4
  %gep.src.2.1 = getelementptr inbounds i32, ptr %src.2, i32 1
  %l.src.2.1 = load i32, ptr %gep.src.2.1, align 4
  %mul.1 = mul nsw i32 %l.src.1.1, %l.src.2.1
  %add.1 = add i32 %mul.1, 9

  %gep.src.1.2 = getelementptr inbounds i32, ptr %src.1, i32 2
  %l.src.1.2 = load i32, ptr %gep.src.1.2, align 4
  %gep.src.2.2 = getelementptr inbounds i32, ptr %src.2, i32 2
  %l.src.2.2 = load i32, ptr %gep.src.2.2, align 4
  %mul.2 = mul nsw i32 %l.src.1.2, %l.src.2.2
  %add.2 = add i32 %mul.2, 9

  store i32 %add.0, ptr %dst

  %dst.1 = getelementptr i32, ptr %dst, i32 1
  store i32 %add.1, ptr %dst.1

  %dst.2 = getelementptr i32, ptr %dst, i32 2
  store i32 %add.2, ptr %dst.2

  ret void
}

define void @v3_load_f32_fadd_fadd_by_constant_store(ptr %src, ptr %dst) {
; CHECK-LABEL: @v3_load_f32_fadd_fadd_by_constant_store(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_SRC_0:%.*]] = getelementptr inbounds float, ptr [[SRC:%.*]], i32 0
; CHECK-NEXT:    [[TMP0:%.*]] = load <3 x float>, ptr [[GEP_SRC_0]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <3 x float> [[TMP0]], <3 x float> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 4>
; CHECK-NEXT:    [[TMP2:%.*]] = fadd <4 x float> [[TMP1]], <float 1.000000e+01, float 1.000000e+01, float 1.000000e+01, float undef>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x float> [[TMP2]], <4 x float> poison, <3 x i32> <i32 0, i32 1, i32 2>
; CHECK-NEXT:    store <3 x float> [[TMP3]], ptr [[DST:%.*]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %gep.src.0 = getelementptr inbounds float, ptr %src, i32 0
  %l.src.0 = load float , ptr %gep.src.0, align 4
  %fadd.0 = fadd float %l.src.0, 10.0

  %gep.src.1 = getelementptr inbounds float , ptr %src, i32 1
  %l.src.1 = load float, ptr %gep.src.1, align 4
  %fadd.1 = fadd float %l.src.1, 10.0

  %gep.src.2 = getelementptr inbounds float, ptr %src, i32 2
  %l.src.2 = load float, ptr %gep.src.2, align 4
  %fadd.2 = fadd float %l.src.2, 10.0

  store float %fadd.0, ptr %dst

  %dst.1 = getelementptr float, ptr %dst, i32 1
  store float %fadd.1, ptr %dst.1

  %dst.2 = getelementptr float, ptr %dst, i32 2
  store float %fadd.2, ptr %dst.2

  ret void
}


define void @phi_store3(ptr %dst) {
; CHECK-LABEL: @phi_store3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       invoke.cont8.loopexit:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[P_2:%.*]] = phi i32 [ 3, [[ENTRY:%.*]] ], [ 0, [[INVOKE_CONT8_LOOPEXIT:%.*]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = phi <2 x i32> [ <i32 1, i32 2>, [[ENTRY]] ], [ poison, [[INVOKE_CONT8_LOOPEXIT]] ]
; CHECK-NEXT:    [[DST_2:%.*]] = getelementptr i32, ptr [[DST:%.*]], i32 2
; CHECK-NEXT:    store <2 x i32> [[TMP0]], ptr [[DST]], align 4
; CHECK-NEXT:    store i32 [[P_2]], ptr [[DST_2]], align 4
; CHECK-NEXT:    ret void
;
entry:
  br label %exit

invoke.cont8.loopexit:                            ; No predecessors!
  br label %exit

exit:
  %p.0 = phi i32 [ 1, %entry ], [ 0, %invoke.cont8.loopexit ]
  %p.1 = phi i32 [ 2, %entry ], [ 0, %invoke.cont8.loopexit ]
  %p.2 = phi i32 [ 3, %entry ], [ 0, %invoke.cont8.loopexit ]

  %dst.1 = getelementptr i32, ptr %dst, i32 1
  %dst.2 = getelementptr i32, ptr %dst, i32 2

  store i32 %p.0, ptr %dst, align 4
  store i32 %p.1, ptr %dst.1, align 4
  store i32 %p.2, ptr %dst.2, align 4
  ret void
}

define void @store_try_reorder(ptr %dst) {
; CHECK-LABEL: @store_try_reorder(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 0, 0
; CHECK-NEXT:    store i32 [[ADD]], ptr [[DST:%.*]], align 4
; CHECK-NEXT:    [[ARRAYIDX_I1887:%.*]] = getelementptr i32, ptr [[DST]], i64 1
; CHECK-NEXT:    store <2 x i32> zeroinitializer, ptr [[ARRAYIDX_I1887]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %add = add i32 0, 0
  store i32 %add, ptr %dst, align 4
  %add207 = sub i32 0, 0
  %arrayidx.i1887 = getelementptr i32, ptr %dst, i64 1
  store i32 %add207, ptr %arrayidx.i1887, align 4
  %add216 = sub i32 0, 0
  %arrayidx.i1891 = getelementptr i32, ptr %dst, i64 2
  store i32 %add216, ptr %arrayidx.i1891, align 4
  ret void
}

%struct.zot = type { i32, i32, i32 }

define i1 @reorder_results(ptr %arg, i1 %arg1, ptr %arg2, i64 %arg3, ptr %arg4) {
; CHECK-LABEL: @reorder_results(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[ARG4:%.*]], align 8
; CHECK-NEXT:    [[LOAD4:%.*]] = load i32, ptr [[LOAD]], align 4
; CHECK-NEXT:    [[GETELEMENTPTR:%.*]] = getelementptr i8, ptr [[LOAD]], i64 4
; CHECK-NEXT:    [[LOAD5:%.*]] = load i32, ptr [[GETELEMENTPTR]], align 4
; CHECK-NEXT:    [[GETELEMENTPTR6:%.*]] = getelementptr i8, ptr [[LOAD]], i64 8
; CHECK-NEXT:    [[LOAD7:%.*]] = load i32, ptr [[GETELEMENTPTR6]], align 4
; CHECK-NEXT:    br i1 [[ARG1:%.*]], label [[BB12:%.*]], label [[BB9:%.*]]
; CHECK:       bb8:
; CHECK-NEXT:    ret i1 false
; CHECK:       bb9:
; CHECK-NEXT:    [[FREEZE:%.*]] = freeze ptr [[ARG:%.*]]
; CHECK-NEXT:    store i32 [[LOAD4]], ptr [[FREEZE]], align 4
; CHECK-NEXT:    [[GETELEMENTPTR10:%.*]] = getelementptr i8, ptr [[FREEZE]], i64 4
; CHECK-NEXT:    store i32 [[LOAD7]], ptr [[GETELEMENTPTR10]], align 4
; CHECK-NEXT:    [[GETELEMENTPTR11:%.*]] = getelementptr i8, ptr [[FREEZE]], i64 8
; CHECK-NEXT:    store i32 [[LOAD5]], ptr [[GETELEMENTPTR11]], align 4
; CHECK-NEXT:    br label [[BB8:%.*]]
; CHECK:       bb12:
; CHECK-NEXT:    [[GETELEMENTPTR13:%.*]] = getelementptr [[STRUCT_ZOT:%.*]], ptr [[ARG2:%.*]], i64 [[ARG3:%.*]]
; CHECK-NEXT:    store i32 [[LOAD4]], ptr [[GETELEMENTPTR13]], align 4
; CHECK-NEXT:    [[GETELEMENTPTR14:%.*]] = getelementptr i8, ptr [[GETELEMENTPTR13]], i64 4
; CHECK-NEXT:    store i32 [[LOAD7]], ptr [[GETELEMENTPTR14]], align 4
; CHECK-NEXT:    [[GETELEMENTPTR15:%.*]] = getelementptr i8, ptr [[GETELEMENTPTR13]], i64 8
; CHECK-NEXT:    store i32 [[LOAD5]], ptr [[GETELEMENTPTR15]], align 4
; CHECK-NEXT:    br label [[BB8]]
;
bb:
  %load = load ptr, ptr %arg4, align 8
  %load4 = load i32, ptr %load, align 4
  %getelementptr = getelementptr i8, ptr %load, i64 4
  %load5 = load i32, ptr %getelementptr, align 4
  %getelementptr6 = getelementptr i8, ptr %load, i64 8
  %load7 = load i32, ptr %getelementptr6, align 4
  br i1 %arg1, label %bb12, label %bb9

bb8:                                              ; preds = %bb12, %bb9
  ret i1 false

bb9:                                              ; preds = %bb
  %freeze = freeze ptr %arg
  store i32 %load4, ptr %freeze, align 4
  %getelementptr10 = getelementptr i8, ptr %freeze, i64 4
  store i32 %load7, ptr %getelementptr10, align 4
  %getelementptr11 = getelementptr i8, ptr %freeze, i64 8
  store i32 %load5, ptr %getelementptr11, align 4
  br label %bb8

bb12:                                             ; preds = %bb
  %getelementptr13 = getelementptr %struct.zot, ptr %arg2, i64 %arg3
  store i32 %load4, ptr %getelementptr13, align 4
  %getelementptr14 = getelementptr i8, ptr %getelementptr13, i64 4
  store i32 %load7, ptr %getelementptr14, align 4
  %getelementptr15 = getelementptr i8, ptr %getelementptr13, i64 8
  store i32 %load5, ptr %getelementptr15, align 4
  br label %bb8
}


define void @vec3_fmuladd_64(ptr %Colour, double %0) {
; CHECK-LABEL: @vec3_fmuladd_64(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAYIDX80:%.*]] = getelementptr float, ptr [[COLOUR:%.*]], i64 2
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[TMP0:%.*]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <2 x double> [[TMP1]], <2 x double> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP3:%.*]] = call <2 x double> @llvm.fmuladd.v2f64(<2 x double> [[TMP2]], <2 x double> zeroinitializer, <2 x double> zeroinitializer)
; CHECK-NEXT:    [[TMP4:%.*]] = fptrunc <2 x double> [[TMP3]] to <2 x float>
; CHECK-NEXT:    store <2 x float> [[TMP4]], ptr [[COLOUR]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = call double @llvm.fmuladd.f64(double [[TMP0]], double 0.000000e+00, double 0.000000e+00)
; CHECK-NEXT:    [[CONV82:%.*]] = fptrunc double [[TMP5]] to float
; CHECK-NEXT:    store float [[CONV82]], ptr [[ARRAYIDX80]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %arrayidx72 = getelementptr float, ptr %Colour, i64 1
  %arrayidx80 = getelementptr float, ptr %Colour, i64 2
  %1 = call double @llvm.fmuladd.f64(double %0, double 0.000000e+00, double 0.000000e+00)
  %conv66 = fptrunc double %1 to float
  store float %conv66, ptr %Colour, align 4
  %2 = call double @llvm.fmuladd.f64(double %0, double 0.000000e+00, double 0.000000e+00)
  %conv74 = fptrunc double %2 to float
  store float %conv74, ptr %arrayidx72, align 4
  %3 = call double @llvm.fmuladd.f64(double %0, double 0.000000e+00, double 0.000000e+00)
  %conv82 = fptrunc double %3 to float
  store float %conv82, ptr %arrayidx80, align 4
  ret void
}

define void @vec3_fpext_cost(ptr %Colour, float %0) {
; CHECK-LABEL: @vec3_fpext_cost(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAYIDX80:%.*]] = getelementptr float, ptr [[COLOUR:%.*]], i64 2
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x float> poison, float [[TMP0:%.*]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <2 x float> [[TMP1]], <2 x float> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP3:%.*]] = fpext <2 x float> [[TMP2]] to <2 x double>
; CHECK-NEXT:    [[TMP4:%.*]] = call <2 x double> @llvm.fmuladd.v2f64(<2 x double> [[TMP3]], <2 x double> zeroinitializer, <2 x double> zeroinitializer)
; CHECK-NEXT:    [[TMP5:%.*]] = fptrunc <2 x double> [[TMP4]] to <2 x float>
; CHECK-NEXT:    store <2 x float> [[TMP5]], ptr [[COLOUR]], align 4
; CHECK-NEXT:    [[CONV78:%.*]] = fpext float [[TMP0]] to double
; CHECK-NEXT:    [[TMP6:%.*]] = call double @llvm.fmuladd.f64(double [[CONV78]], double 0.000000e+00, double 0.000000e+00)
; CHECK-NEXT:    [[CONV82:%.*]] = fptrunc double [[TMP6]] to float
; CHECK-NEXT:    store float [[CONV82]], ptr [[ARRAYIDX80]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %arrayidx72 = getelementptr float, ptr %Colour, i64 1
  %arrayidx80 = getelementptr float, ptr %Colour, i64 2
  %conv62 = fpext float %0 to double
  %1 = call double @llvm.fmuladd.f64(double %conv62, double 0.000000e+00, double 0.000000e+00)
  %conv66 = fptrunc double %1 to float
  store float %conv66, ptr %Colour, align 4
  %conv70 = fpext float %0 to double
  %2 = call double @llvm.fmuladd.f64(double %conv70, double 0.000000e+00, double 0.000000e+00)
  %conv74 = fptrunc double %2 to float
  store float %conv74, ptr %arrayidx72, align 4
  %conv78 = fpext float %0 to double
  %3 = call double @llvm.fmuladd.f64(double %conv78, double 0.000000e+00, double 0.000000e+00)
  %conv82 = fptrunc double %3 to float
  store float %conv82, ptr %arrayidx80, align 4
  ret void
}

define void @fpext_gather(ptr %dst, double %conv) {
; CHECK-LABEL: @fpext_gather(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = insertelement <2 x double> poison, double [[CONV:%.*]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <2 x double> [[TMP0]], <2 x double> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP2:%.*]] = fptrunc <2 x double> [[TMP1]] to <2 x float>
; CHECK-NEXT:    [[LENGTHS:%.*]] = getelementptr float, ptr [[DST:%.*]], i64 0
; CHECK-NEXT:    [[TMP3:%.*]] = extractelement <2 x float> [[TMP2]], i32 0
; CHECK-NEXT:    store float [[TMP3]], ptr [[LENGTHS]], align 4
; CHECK-NEXT:    [[ARRAYIDX32:%.*]] = getelementptr float, ptr [[DST]], i64 1
; CHECK-NEXT:    store <2 x float> [[TMP2]], ptr [[ARRAYIDX32]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %conv25 = fptrunc double %conv to float
  %Lengths = getelementptr float, ptr %dst, i64 0
  store float %conv25, ptr %Lengths, align 4
  %arrayidx32 = getelementptr float, ptr %dst, i64 1
  store float %conv25, ptr %arrayidx32, align 4
  %conv34 = fptrunc double %conv to float
  %arrayidx37 = getelementptr float, ptr %dst, i64 2
  store float %conv34, ptr %arrayidx37, align 4
  ret void
}

define void @extract_mask(ptr %object, double %conv503, double %conv520) {
; CHECK-LABEL: @extract_mask(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[OBJECT:%.*]], align 8
; CHECK-NEXT:    [[BBOX483:%.*]] = getelementptr float, ptr [[TMP0]]
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x float>, ptr [[BBOX483]], align 8
; CHECK-NEXT:    [[TMP2:%.*]] = fpext <2 x float> [[TMP1]] to <2 x double>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <2 x double> [[TMP2]], <2 x double> poison, <2 x i32> <i32 1, i32 0>
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[CONV503:%.*]], i32 0
; CHECK-NEXT:    [[TMP5:%.*]] = fcmp ogt <2 x double> [[TMP4]], <double 0.000000e+00, double -2.000000e+10>
; CHECK-NEXT:    [[TMP6:%.*]] = select <2 x i1> [[TMP5]], <2 x double> [[TMP3]], <2 x double> <double 0.000000e+00, double -2.000000e+10>
; CHECK-NEXT:    [[TMP7:%.*]] = fsub <2 x double> zeroinitializer, [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = fptrunc <2 x double> [[TMP7]] to <2 x float>
; CHECK-NEXT:    [[TMP9:%.*]] = extractelement <2 x float> [[TMP8]], i32 0
; CHECK-NEXT:    [[TMP10:%.*]] = extractelement <2 x float> [[TMP8]], i32 1
; CHECK-NEXT:    [[MUL646:%.*]] = fmul float [[TMP9]], [[TMP10]]
; CHECK-NEXT:    [[CMP663:%.*]] = fcmp olt float [[MUL646]], 0.000000e+00
; CHECK-NEXT:    br i1 [[CMP663]], label [[IF_THEN665:%.*]], label [[IF_END668:%.*]]
; CHECK:       if.then665:
; CHECK-NEXT:    [[ARRAYIDX656:%.*]] = getelementptr float, ptr [[OBJECT]], i64 10
; CHECK-NEXT:    [[BBOX651:%.*]] = getelementptr float, ptr [[OBJECT]]
; CHECK-NEXT:    [[CONV621:%.*]] = fptrunc double [[CONV520:%.*]] to float
; CHECK-NEXT:    [[TMP11:%.*]] = shufflevector <2 x double> [[TMP6]], <2 x double> poison, <2 x i32> <i32 poison, i32 0>
; CHECK-NEXT:    [[TMP12:%.*]] = insertelement <2 x double> [[TMP11]], double [[CONV503]], i32 0
; CHECK-NEXT:    [[TMP13:%.*]] = fptrunc <2 x double> [[TMP12]] to <2 x float>
; CHECK-NEXT:    store <2 x float> [[TMP13]], ptr [[BBOX651]], align 8
; CHECK-NEXT:    [[BBOX_SROA_8_0_BBOX666_SROA_IDX:%.*]] = getelementptr float, ptr [[OBJECT]], i64 2
; CHECK-NEXT:    store float [[CONV621]], ptr [[BBOX_SROA_8_0_BBOX666_SROA_IDX]], align 8
; CHECK-NEXT:    store <2 x float> [[TMP8]], ptr [[ARRAYIDX656]], align 8
; CHECK-NEXT:    br label [[IF_END668]]
; CHECK:       if.end668:
; CHECK-NEXT:    ret void
;
entry:
  %0 = load ptr, ptr %object, align 8
  %bbox483 = getelementptr float, ptr %0
  %1 = load float, ptr %bbox483, align 8
  %conv486 = fpext float %1 to double
  %cmp487 = fcmp ogt double %conv486, -2.000000e+10
  %conv486.2 = select i1 %cmp487, double %conv486, double -2.000000e+10
  %arrayidx502 = getelementptr float, ptr %0, i64 1
  %2 = load float, ptr %arrayidx502, align 4
  %conv5033 = fpext float %2 to double
  %cmp504 = fcmp ogt double %conv503, 0.000000e+00
  %cond514 = select i1 %cmp504, double %conv5033, double 0.000000e+00
  %sub626 = fsub double 0.000000e+00, %conv486.2
  %conv627 = fptrunc double %sub626 to float
  %sub632 = fsub double 0.000000e+00, %cond514
  %conv633 = fptrunc double %sub632 to float
  %mul646 = fmul float %conv633, %conv627
  %cmp663 = fcmp olt float %mul646, 0.000000e+00
  br i1 %cmp663, label %if.then665, label %if.end668

if.then665:                                       ; preds = %entry
  %arrayidx656 = getelementptr float, ptr %object, i64 10
  %lengths652 = getelementptr float, ptr %object, i64 11
  %bbox651 = getelementptr float, ptr %object
  %conv621 = fptrunc double %conv520 to float
  %conv617 = fptrunc double %cond514 to float
  %conv613 = fptrunc double %conv503 to float
  store float %conv613, ptr %bbox651, align 8
  %bbox.sroa.6.0.bbox666.sroa_idx = getelementptr float, ptr %object, i64 1
  store float %conv617, ptr %bbox.sroa.6.0.bbox666.sroa_idx, align 4
  %bbox.sroa.8.0.bbox666.sroa_idx = getelementptr float, ptr %object, i64 2
  store float %conv621, ptr %bbox.sroa.8.0.bbox666.sroa_idx, align 8
  store float %conv627, ptr %lengths652, align 4
  store float %conv633, ptr %arrayidx656, align 8
  br label %if.end668

if.end668:                                        ; preds = %if.then665, %entry
  ret void
}

define void @vec3_vectorize_call(ptr %Colour, float %0) {
; CHECK-LABEL: @vec3_vectorize_call(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x float>, ptr [[COLOUR:%.*]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> [[TMP1]], <2 x float> zeroinitializer, <2 x float> zeroinitializer)
; CHECK-NEXT:    store <2 x float> [[TMP2]], ptr [[COLOUR]], align 4
; CHECK-NEXT:    [[ARRAYIDX99_I1:%.*]] = getelementptr float, ptr [[COLOUR]], i64 2
; CHECK-NEXT:    [[TMP3:%.*]] = call float @llvm.fmuladd.f32(float [[TMP0:%.*]], float 0.000000e+00, float 0.000000e+00)
; CHECK-NEXT:    store float [[TMP3]], ptr [[ARRAYIDX99_I1]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %1 = load float, ptr %Colour, align 4
  %2 = call float @llvm.fmuladd.f32(float %1, float 0.000000e+00, float 0.000000e+00)
  store float %2, ptr %Colour, align 4
  %arrayidx91.i = getelementptr float, ptr %Colour, i64 1
  %3 = load float, ptr %arrayidx91.i, align 4
  %4 = call float @llvm.fmuladd.f32(float %3, float 0.000000e+00, float 0.000000e+00)
  store float %4, ptr %arrayidx91.i, align 4
  %arrayidx99.i1 = getelementptr float, ptr %Colour, i64 2
  %5 = call float @llvm.fmuladd.f32(float %0, float 0.000000e+00, float 0.000000e+00)
  store float %5, ptr %arrayidx99.i1, align 4
  ret void
}

define void @gather_2(ptr %mat1, float %0, float %1) {
; CHECK-LABEL: @gather_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP2:%.*]] = call float @llvm.fmuladd.f32(float [[TMP0:%.*]], float 0.000000e+00, float 0.000000e+00)
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x float> poison, float [[TMP1:%.*]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x float> [[TMP3]], float [[TMP0]], i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <2 x float> [[TMP4]], <2 x float> poison, <2 x i32> <i32 1, i32 0>
; CHECK-NEXT:    [[TMP6:%.*]] = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> [[TMP4]], <2 x float> [[TMP5]], <2 x float> zeroinitializer)
; CHECK-NEXT:    [[TMP7:%.*]] = fmul float [[TMP2]], 0.000000e+00
; CHECK-NEXT:    [[ARRAYIDX163:%.*]] = getelementptr [4 x [4 x float]], ptr [[MAT1:%.*]], i64 0, i64 1
; CHECK-NEXT:    [[ARRAYIDX2_I_I_I278:%.*]] = getelementptr [4 x [4 x float]], ptr [[MAT1]], i64 0, i64 1, i64 1
; CHECK-NEXT:    store float [[TMP7]], ptr [[ARRAYIDX163]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = fmul <2 x float> [[TMP6]], zeroinitializer
; CHECK-NEXT:    store <2 x float> [[TMP8]], ptr [[ARRAYIDX2_I_I_I278]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %2 = call float @llvm.fmuladd.f32(float %0, float 0.000000e+00, float 0.000000e+00)
  %3 = call float @llvm.fmuladd.f32(float %1, float %0, float 0.000000e+00)
  %4 = call float @llvm.fmuladd.f32(float %0, float %1, float 0.000000e+00)
  %5 = fmul float %2, 0.000000e+00
  %6 = fmul float %3, 0.000000e+00
  %7 = fmul float %4, 0.000000e+00
  %arrayidx163 = getelementptr [4 x [4 x float]], ptr %mat1, i64 0, i64 1
  %arrayidx2.i.i.i278 = getelementptr [4 x [4 x float]], ptr %mat1, i64 0, i64 1, i64 1
  %arrayidx5.i.i.i280 = getelementptr [4 x [4 x float]], ptr %mat1, i64 0, i64 1, i64 2
  store float %5, ptr %arrayidx163, align 4
  store float %6, ptr %arrayidx2.i.i.i278, align 4
  store float %7, ptr %arrayidx5.i.i.i280, align 4
  ret void
}

define i32 @reorder_indices(float %0) {
; CHECK-LABEL: @reorder_indices(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[NOR1:%.*]] = alloca [0 x [3 x float]], i32 0, align 4
; CHECK-NEXT:    [[ARRAYIDX2_I265:%.*]] = getelementptr float, ptr [[NOR1]], i64 2
; CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX2_I265]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load <2 x float>, ptr [[NOR1]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = extractelement <2 x float> [[TMP2]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = fneg float [[TMP3]]
; CHECK-NEXT:    [[NEG11_I:%.*]] = fmul float [[TMP4]], [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP5:%.*]] = call float @llvm.fmuladd.f32(float [[TMP1]], float 0.000000e+00, float [[NEG11_I]])
; CHECK-NEXT:    [[TMP6:%.*]] = insertelement <2 x float> poison, float [[TMP1]], i32 0
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <2 x float> [[TMP6]], <2 x float> [[TMP2]], <2 x i32> <i32 0, i32 3>
; CHECK-NEXT:    [[TMP8:%.*]] = fneg <2 x float> [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = insertelement <2 x float> poison, float [[TMP0]], i32 0
; CHECK-NEXT:    [[TMP10:%.*]] = shufflevector <2 x float> [[TMP9]], <2 x float> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP11:%.*]] = fmul <2 x float> [[TMP8]], [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = shufflevector <2 x float> [[TMP11]], <2 x float> poison, <2 x i32> <i32 1, i32 0>
; CHECK-NEXT:    [[TMP13:%.*]] = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> [[TMP2]], <2 x float> zeroinitializer, <2 x float> [[TMP12]])
; CHECK-NEXT:    [[TMP14:%.*]] = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> [[TMP10]], <2 x float> [[TMP13]], <2 x float> zeroinitializer)
; CHECK-NEXT:    [[TMP15:%.*]] = call float @llvm.fmuladd.f32(float [[TMP0]], float [[TMP5]], float 0.000000e+00)
; CHECK-NEXT:    [[TMP16:%.*]] = fmul <2 x float> [[TMP14]], zeroinitializer
; CHECK-NEXT:    [[MUL6_I_I_I:%.*]] = fmul float [[TMP15]], 0.000000e+00
; CHECK-NEXT:    store <2 x float> [[TMP16]], ptr [[NOR1]], align 4
; CHECK-NEXT:    store float [[MUL6_I_I_I]], ptr [[ARRAYIDX2_I265]], align 4
; CHECK-NEXT:    ret i32 0
;
entry:
  %nor1 = alloca [0 x [3 x float]], i32 0, align 4
  %arrayidx.i = getelementptr float, ptr %nor1, i64 1
  %1 = load float, ptr %arrayidx.i, align 4
  %arrayidx2.i265 = getelementptr float, ptr %nor1, i64 2
  %2 = load float, ptr %arrayidx2.i265, align 4
  %3 = fneg float %2
  %neg.i267 = fmul float %3, %0
  %4 = call float @llvm.fmuladd.f32(float %1, float 0.000000e+00, float %neg.i267)
  %5 = load float, ptr %nor1, align 4
  %6 = fneg float %5
  %neg11.i = fmul float %6, %0
  %7 = call float @llvm.fmuladd.f32(float %2, float 0.000000e+00, float %neg11.i)
  %8 = fneg float %1
  %neg18.i = fmul float %8, %0
  %9 = call float @llvm.fmuladd.f32(float %5, float 0.000000e+00, float %neg18.i)
  %10 = call float @llvm.fmuladd.f32(float %0, float %9, float 0.000000e+00)
  %11 = call float @llvm.fmuladd.f32(float %0, float %4, float 0.000000e+00)
  %12 = call float @llvm.fmuladd.f32(float %0, float %7, float 0.000000e+00)
  %mul.i.i.i = fmul float %10, 0.000000e+00
  %mul3.i.i.i = fmul float %11, 0.000000e+00
  %mul6.i.i.i = fmul float %12, 0.000000e+00
  store float %mul.i.i.i, ptr %nor1, align 4
  store float %mul3.i.i.i, ptr %arrayidx.i, align 4
  store float %mul6.i.i.i, ptr %arrayidx2.i265, align 4
  ret i32 0
}

define void @reuse_shuffle_indidces_1(ptr %col, float %0, float %1) {
; CHECK-LABEL: @reuse_shuffle_indidces_1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <4 x float> <float poison, float poison, float poison, float undef>, float [[TMP1:%.*]], i32 0
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <4 x float> [[TMP2]], float [[TMP0:%.*]], i32 1
; CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x float> [[TMP3]], <4 x float> poison, <4 x i32> <i32 0, i32 1, i32 1, i32 3>
; CHECK-NEXT:    [[TMP5:%.*]] = fmul <4 x float> [[TMP4]], <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>
; CHECK-NEXT:    [[TMP6:%.*]] = fadd <4 x float> [[TMP5]], <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <4 x float> [[TMP6]], <4 x float> poison, <3 x i32> <i32 0, i32 1, i32 2>
; CHECK-NEXT:    store <3 x float> [[TMP7]], ptr [[COL:%.*]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %mul24 = fmul float %1, 0.000000e+00
  %2 = fadd float %mul24, 0.000000e+00
  store float %2, ptr %col, align 4
  %arrayidx26 = getelementptr float, ptr %col, i64 1
  %mul31 = fmul float %0, 0.000000e+00
  %3 = fadd float %mul31, 0.000000e+00
  store float %3, ptr %arrayidx26, align 4
  %arrayidx33 = getelementptr float, ptr %col, i64 2
  %mul38 = fmul float %0, 0.000000e+00
  %4 = fadd float %mul38, 0.000000e+00
  store float %4, ptr %arrayidx33, align 4
  ret void
}

define void @reuse_shuffle_indices_2(ptr %inertia, double %0) {
; CHECK-LABEL: @reuse_shuffle_indices_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[TMP0:%.*]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <2 x double> [[TMP1]], <2 x double> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP3:%.*]] = fptrunc <2 x double> [[TMP2]] to <2 x float>
; CHECK-NEXT:    [[TMP4:%.*]] = fmul <2 x float> [[TMP3]], zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <2 x float> [[TMP4]], <2 x float> poison, <4 x i32> <i32 0, i32 1, i32 1, i32 poison>
; CHECK-NEXT:    [[TMP6:%.*]] = fadd <4 x float> [[TMP5]], <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>
; CHECK-NEXT:    [[TMP7:%.*]] = fmul <4 x float> [[TMP6]], <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>
; CHECK-NEXT:    [[TMP8:%.*]] = fadd <4 x float> [[TMP7]], <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>
; CHECK-NEXT:    [[TMP9:%.*]] = shufflevector <4 x float> [[TMP8]], <4 x float> poison, <3 x i32> <i32 0, i32 1, i32 2>
; CHECK-NEXT:    store <3 x float> [[TMP9]], ptr [[INERTIA:%.*]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %1 = insertelement <2 x double> poison, double %0, i32 0
  %2 = shufflevector <2 x double> %1, <2 x double> poison, <2 x i32> zeroinitializer
  %3 = fptrunc <2 x double> %2 to <2 x float>
  %4 = fmul <2 x float> %3, zeroinitializer
  %5 = shufflevector <2 x float> %4, <2 x float> poison, <4 x i32> <i32 0, i32 1, i32 1, i32 poison>
  %6 = fadd <4 x float> %5, <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>
  %7 = fmul <4 x float> %6, <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>
  %8 = fadd <4 x float> %7, <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>
  %9 = shufflevector <4 x float> %8, <4 x float> poison, <3 x i32> <i32 0, i32 1, i32 2>
  store <3 x float> %9, ptr %inertia, align 4
  ret void
}

define void @reuse_shuffle_indices_cost_crash_2(ptr %bezt, float %0) {
; CHECK-LABEL: @reuse_shuffle_indices_cost_crash_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[FNEG:%.*]] = fmul float [[TMP0:%.*]], 0.000000e+00
; CHECK-NEXT:    [[TMP1:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP0]], float [[FNEG]], float 0.000000e+00)
; CHECK-NEXT:    store float [[TMP1]], ptr [[BEZT:%.*]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP0]], float [[FNEG]], float 0.000000e+00)
; CHECK-NEXT:    [[ARRAYIDX5_I:%.*]] = getelementptr float, ptr [[BEZT]], i64 1
; CHECK-NEXT:    store float [[TMP2]], ptr [[ARRAYIDX5_I]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = tail call float @llvm.fmuladd.f32(float [[FNEG]], float 0.000000e+00, float 0.000000e+00)
; CHECK-NEXT:    [[ARRAYIDX8_I831:%.*]] = getelementptr float, ptr [[BEZT]], i64 2
; CHECK-NEXT:    store float [[TMP3]], ptr [[ARRAYIDX8_I831]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %fneg = fmul float %0, 0.000000e+00
  %1 = tail call float @llvm.fmuladd.f32(float %0, float %fneg, float 0.000000e+00)
  store float %1, ptr %bezt, align 4
  %2 = tail call float @llvm.fmuladd.f32(float %0, float %fneg, float 0.000000e+00)
  %arrayidx5.i = getelementptr float, ptr %bezt, i64 1
  store float %2, ptr %arrayidx5.i, align 4
  %3 = tail call float @llvm.fmuladd.f32(float %fneg, float 0.000000e+00, float 0.000000e+00)
  %arrayidx8.i831 = getelementptr float, ptr %bezt, i64 2
  store float %3, ptr %arrayidx8.i831, align 4
  ret void
}

define void @reuse_shuffle_indices_cost_crash_3(ptr %m, double %conv, double %conv2) {
; CHECK-LABEL: @reuse_shuffle_indices_cost_crash_3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SUB19:%.*]] = fsub double 0.000000e+00, [[CONV2:%.*]]
; CHECK-NEXT:    [[CONV20:%.*]] = fptrunc double [[SUB19]] to float
; CHECK-NEXT:    store float [[CONV20]], ptr [[M:%.*]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = fadd double [[CONV:%.*]], 0.000000e+00
; CHECK-NEXT:    [[CONV239:%.*]] = fptrunc double [[ADD]] to float
; CHECK-NEXT:    [[ARRAYIDX25:%.*]] = getelementptr [4 x float], ptr [[M]], i64 0, i64 1
; CHECK-NEXT:    store float [[CONV239]], ptr [[ARRAYIDX25]], align 4
; CHECK-NEXT:    [[ADD26:%.*]] = fsub double [[CONV]], [[CONV]]
; CHECK-NEXT:    [[CONV27:%.*]] = fptrunc double [[ADD26]] to float
; CHECK-NEXT:    [[ARRAYIDX29:%.*]] = getelementptr [4 x float], ptr [[M]], i64 0, i64 2
; CHECK-NEXT:    store float [[CONV27]], ptr [[ARRAYIDX29]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %sub19 = fsub double 0.000000e+00, %conv2
  %conv20 = fptrunc double %sub19 to float
  store float %conv20, ptr %m, align 4
  %add = fadd double %conv, 0.000000e+00
  %conv239 = fptrunc double %add to float
  %arrayidx25 = getelementptr [4 x float], ptr %m, i64 0, i64 1
  store float %conv239, ptr %arrayidx25, align 4
  %add26 = fsub double %conv, %conv
  %conv27 = fptrunc double %add26 to float
  %arrayidx29 = getelementptr [4 x float], ptr %m, i64 0, i64 2
  store float %conv27, ptr %arrayidx29, align 4
  ret void
}

define void @common_mask(ptr %m, double %conv, double %conv2) {
; CHECK-LABEL: @common_mask(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SUB19:%.*]] = fsub double [[CONV:%.*]], [[CONV]]
; CHECK-NEXT:    [[CONV20:%.*]] = fptrunc double [[SUB19]] to float
; CHECK-NEXT:    store float [[CONV20]], ptr [[M:%.*]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = fadd double [[CONV2:%.*]], 0.000000e+00
; CHECK-NEXT:    [[CONV239:%.*]] = fptrunc double [[ADD]] to float
; CHECK-NEXT:    [[ARRAYIDX25:%.*]] = getelementptr [4 x float], ptr [[M]], i64 0, i64 1
; CHECK-NEXT:    store float [[CONV239]], ptr [[ARRAYIDX25]], align 4
; CHECK-NEXT:    [[ADD26:%.*]] = fsub double 0.000000e+00, [[CONV]]
; CHECK-NEXT:    [[CONV27:%.*]] = fptrunc double [[ADD26]] to float
; CHECK-NEXT:    [[ARRAYIDX29:%.*]] = getelementptr [4 x float], ptr [[M]], i64 0, i64 2
; CHECK-NEXT:    store float [[CONV27]], ptr [[ARRAYIDX29]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %sub19 = fsub double %conv, %conv
  %conv20 = fptrunc double %sub19 to float
  store float %conv20, ptr %m, align 4
  %add = fadd double %conv2, 0.000000e+00
  %conv239 = fptrunc double %add to float
  %arrayidx25 = getelementptr [4 x float], ptr %m, i64 0, i64 1
  store float %conv239, ptr %arrayidx25, align 4
  %add26 = fsub double 0.000000e+00, %conv
  %conv27 = fptrunc double %add26 to float
  %arrayidx29 = getelementptr [4 x float], ptr %m, i64 0, i64 2
  store float %conv27, ptr %arrayidx29, align 4
  ret void
}

attributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
declare float @llvm.fmuladd.f32(float, float, float)

declare double @llvm.fmuladd.f64(double, double, double)
